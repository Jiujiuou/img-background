# 图片拖拽功能实现方案

## 📋 功能需求分析

### 核心需求

1. **点击图片进入拖拽模式**：用户点击预览区域中的图片时，启用拖拽功能
2. **实时拖拽移动**：鼠标拖拽过程中，图片位置实时跟随鼠标移动
3. **右侧控件联动**：拖拽过程中，右侧的"垂直位置"和"水平位置"滑动条实时更新
4. **边界限制**：防止图片拖拽超出合理的可视范围
5. **拖拽完成**：松开鼠标后，完成位置调整并保存状态

### 技术挑战

- 坐标系转换：鼠标坐标 → 图片相对位置 → 百分比数值
- 实时性能：拖拽过程中的流畅度和响应性
- 状态同步：确保拖拽状态与 Zustand store 的一致性
- 边界处理：图片不能拖拽到不合理的位置

## 🎯 技术实现方案

### 1. 组件架构设计

#### 1.1 新增组件结构

```
src/component/
├── DraggableImage/              # 新增：可拖拽图片组件
│   ├── DraggableImage.jsx       # 主组件文件
│   ├── index.module.less        # 样式文件
│   └── hooks/                   # 自定义 hooks
│       └── useDrag.js           # 拖拽逻辑 hook
```

#### 1.2 组件职责划分

- **DraggableImage**: 包装现有图片，添加拖拽功能
- **useDrag Hook**: 封装拖拽逻辑，处理鼠标事件
- **Preview 组件**: 集成 DraggableImage，保持现有预览功能

### 2. 核心拖拽逻辑实现

#### 2.1 拖拽状态管理

```javascript
// 拖拽过程中的状态数据结构
const dragState = {
  isDragging: false, // 是否正在拖拽
  startMousePos: { x: 0, y: 0 }, // 拖拽开始时的鼠标位置
  startImagePos: { x: 0, y: 0 }, // 拖拽开始时的图片位置
  currentPos: { x: 0, y: 0 }, // 当前图片位置
  containerRect: null, // 容器的边界信息
};
```

#### 2.2 坐标转换计算

```javascript
// 关键计算公式
function calculateImagePosition(mouseX, mouseY, dragState) {
  // 1. 计算鼠标移动距离
  const deltaX = mouseX - dragState.startMousePos.x;
  const deltaY = mouseY - dragState.startMousePos.y;

  // 2. 转换为容器内的相对位置
  const containerWidth = dragState.containerRect.width;
  const containerHeight = dragState.containerRect.height;

  // 3. 计算新的图片位置（百分比）
  const newLeft = dragState.startImagePos.x + (deltaX / containerWidth) * 100;
  const newTop = dragState.startImagePos.y + (deltaY / containerHeight) * 100;

  // 4. 边界限制 - 与 ImageControl 组件保持一致
  const POSITION_MIN = 25; // 对应滑动条 min={25}
  const POSITION_MAX = 75; // 对应滑动条 max={75}
  const boundedLeft = Math.max(POSITION_MIN, Math.min(POSITION_MAX, newLeft));
  const boundedTop = Math.max(POSITION_MIN, Math.min(POSITION_MAX, newTop));

  return { left: boundedLeft, top: boundedTop };
}
```

#### 2.3 事件处理流程

```javascript
// 拖拽事件处理的完整流程
const dragEventFlow = {
  onMouseDown: (event) => {
    // 1. 记录初始状态
    // 2. 添加全局鼠标事件监听
    // 3. 设置拖拽状态为 true
    // 4. 获取容器边界信息
  },

  onMouseMove: (event) => {
    // 1. 检查是否处于拖拽状态
    // 2. 计算新的图片位置
    // 3. 更新 Zustand store
    // 4. 触发重新渲染
  },

  onMouseUp: (event) => {
    // 1. 移除全局事件监听
    // 2. 设置拖拽状态为 false
    // 3. 清理临时状态
    // 4. 保存最终位置
  },
};
```

### 3. 详细代码实现

#### 3.1 useDrag Hook 实现

```javascript
// src/component/DraggableImage/hooks/useDrag.js
import { useState, useCallback, useRef, useEffect } from "react";
import useStore from "@/store";

export const useDrag = (imageRef) => {
  const { updateImageStyle, _ImageStyle } = useStore();
  const [isDragging, setIsDragging] = useState(false);
  const dragStateRef = useRef({
    startMousePos: { x: 0, y: 0 },
    startImagePos: { x: 0, y: 0 },
    containerRect: null,
  });

  // 解析当前图片位置
  const getCurrentPosition = useCallback(() => {
    const top = parseFloat(_ImageStyle.top) || 50;
    const left = parseFloat(_ImageStyle.left) || 50;
    return { x: left, y: top };
  }, [_ImageStyle]);

  // 边界限制函数 - 与 ImageControl 组件保持一致
  const POSITION_MIN = 25; // 对应 ImageControl 中的 min={25}
  const POSITION_MAX = 75; // 对应 ImageControl 中的 max={75}

  const applyBounds = useCallback((left, top) => {
    return {
      left: Math.max(POSITION_MIN, Math.min(POSITION_MAX, left)),
      top: Math.max(POSITION_MIN, Math.min(POSITION_MAX, top)),
    };
  }, []);

  // 计算新位置
  const calculateNewPosition = useCallback(
    (clientX, clientY) => {
      const { startMousePos, startImagePos, containerRect } =
        dragStateRef.current;

      if (!containerRect) return null;

      const deltaX = clientX - startMousePos.x;
      const deltaY = clientY - startMousePos.y;

      const newLeft = startImagePos.x + (deltaX / containerRect.width) * 100;
      const newTop = startImagePos.y + (deltaY / containerRect.height) * 100;

      return applyBounds(newLeft, newTop);
    },
    [applyBounds]
  );

  // 鼠标按下事件
  const handleMouseDown = useCallback(
    (event) => {
      event.preventDefault();
      event.stopPropagation();

      const containerElement = imageRef.current?.closest(
        '[id$="download-area"]'
      );
      if (!containerElement) return;

      const containerRect = containerElement.getBoundingClientRect();
      const currentPos = getCurrentPosition();

      dragStateRef.current = {
        startMousePos: { x: event.clientX, y: event.clientY },
        startImagePos: { x: currentPos.x, y: currentPos.y },
        containerRect,
      };

      setIsDragging(true);

      // 添加全局事件监听
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      document.body.style.userSelect = "none"; // 防止文本选择
    },
    [imageRef, getCurrentPosition]
  );

  // 鼠标移动事件
  const handleMouseMove = useCallback(
    (event) => {
      const newPosition = calculateNewPosition(event.clientX, event.clientY);
      if (!newPosition) return;

      // 更新 Zustand store，触发右侧控件联动
      updateImageStyle({
        ..._ImageStyle,
        top: `${newPosition.top}%`,
        left: `${newPosition.left}%`,
      });
    },
    [calculateNewPosition, updateImageStyle, _ImageStyle]
  );

  // 鼠标释放事件
  const handleMouseUp = useCallback(() => {
    setIsDragging(false);

    // 移除全局事件监听
    document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);
    document.body.style.userSelect = ""; // 恢复文本选择
  }, [handleMouseMove]);

  // 组件卸载时清理事件
  useEffect(() => {
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.body.style.userSelect = "";
    };
  }, [handleMouseMove, handleMouseUp]);

  return {
    isDragging,
    handleMouseDown,
  };
};
```

#### 3.2 DraggableImage 组件实现

```javascript
// src/component/DraggableImage/DraggableImage.jsx
import React, { useRef } from "react";
import useStore from "@/store";
import { useDrag } from "./hooks/useDrag";
import styles from "./index.module.less";

function DraggableImage() {
  const imageRef = useRef(null);
  const _ImageStyle = useStore((state) => state._ImageStyle);
  const _ImageRatio = useStore((state) => state._ImageRatio);
  const _ImageBase64Url = useStore((state) => state._ImageBase64Url);

  const { isDragging, handleMouseDown } = useDrag(imageRef);

  // 计算图片比例样式
  const getImageRatioStyle = () => {
    const { width, height } = _ImageRatio;
    return {
      aspectRatio: `${width} / ${height}`,
    };
  };

  if (!_ImageBase64Url) return null;

  return (
    <img
      ref={imageRef}
      alt=""
      draggable="false"
      className={`${styles.image} ${isDragging ? styles.dragging : ""}`}
      src={_ImageBase64Url}
      style={{
        ..._ImageStyle,
        ...getImageRatioStyle(),
        cursor: isDragging ? "grabbing" : "grab",
      }}
      onMouseDown={handleMouseDown}
    />
  );
}

export default DraggableImage;
```

#### 3.3 样式文件实现

```less
// src/component/DraggableImage/index.module.less
.image {
  position: absolute;
  cursor: grab;
  transition: none; // 拖拽时禁用过渡动画
  user-select: none;

  &:hover {
    // 可以添加 hover 效果，比如边框高亮
    outline: 2px solid rgba(59, 130, 246, 0.3);
    outline-offset: 2px;
  }

  &.dragging {
    cursor: grabbing;
    z-index: 1000; // 确保拖拽时在最上层

    // 拖拽时的视觉反馈
    filter: brightness(1.1);
    transform: scale(1.02);
  }
}

// 拖拽时的全局样式
:global(.dragging-active) {
  * {
    cursor: grabbing !important;
  }
}
```

### 4. 边界控制配置管理

为了确保拖拽功能与现有滑动条控件的边界限制完全一致，我们需要创建统一的配置管理。

#### 4.1 创建边界配置常量

```javascript
// src/constant/boundary.js - 新建边界配置文件
export const BOUNDARY_CONFIG = {
  // 图片位置边界 - 与 ImageControl 组件中的滑动条设置保持一致
  position: {
    min: 25, // 对应 <Slider min={25} ...>
    max: 75, // 对应 <Slider max={75} ...>
    default: 50, // 默认居中位置
  },

  // 图片大小边界
  size: {
    min: 0, // 对应 <Slider min={0} ...>
    max: 100, // 对应 <Slider max={100} ...>
    default: 50,
  },

  // 圆角大小边界
  radius: {
    min: 0, // 对应 <Slider min={0} ...>
    max: 30, // 对应 <Slider max={30} ...>
    default: 8,
  },
};

// 边界检查工具函数
export const clampToBounds = (value, min, max) => {
  return Math.max(min, Math.min(max, value));
};

// 位置边界检查
export const clampPosition = (left, top) => {
  return {
    left: clampToBounds(
      left,
      BOUNDARY_CONFIG.position.min,
      BOUNDARY_CONFIG.position.max
    ),
    top: clampToBounds(
      top,
      BOUNDARY_CONFIG.position.min,
      BOUNDARY_CONFIG.position.max
    ),
  };
};
```

#### 4.2 在拖拽 Hook 中使用统一配置

```javascript
// 在 useDrag.js 中导入边界配置
import { BOUNDARY_CONFIG, clampPosition } from "@/constant/boundary";

export const useDrag = (imageRef) => {
  // ... 其他代码保持不变

  // 使用统一的边界配置
  const applyBounds = useCallback((left, top) => {
    return clampPosition(left, top);
  }, []);

  // ... 其他代码
};
```

#### 4.3 更新 ImageControl 组件使用统一配置

```javascript
// 建议更新 ImageControl.jsx 也使用相同的配置
import { BOUNDARY_CONFIG } from "@/constant/boundary";

function ImageControl() {
  // ... 现有代码

  return (
    <div className={styles.wrapper}>
      <InlineControl label={"垂直位置"}>
        <Slider
          min={BOUNDARY_CONFIG.position.min}
          max={BOUNDARY_CONFIG.position.max}
          step={1}
          value={top}
          onChange={setTop}
        />
      </InlineControl>

      <InlineControl label={"水平位置"}>
        <Slider
          min={BOUNDARY_CONFIG.position.min}
          max={BOUNDARY_CONFIG.position.max}
          step={1}
          value={left}
          onChange={setLeft}
        />
      </InlineControl>

      {/* 其他控件也使用统一配置 */}
    </div>
  );
}
```

#### 4.4 边界设计的合理性分析

**为什么选择 25%-75% 的位置范围？**

1. **视觉平衡**: 确保图片永远不会完全贴边，保持视觉上的呼吸空间
2. **安全边距**: 为不同屏幕比例和输出格式预留安全区域
3. **用户体验**: 防止图片意外移动到视觉效果不佳的极端位置
4. **导出质量**: 确保导出的图片在各种用途下都有良好的展示效果

**动态边界的考虑**:

当图片尺寸很大时（如 size > 80%），可以进一步收紧边界范围：

```javascript
// 根据图片大小动态调整边界
const getDynamicBounds = (imageSize) => {
  const size = parseFloat(imageSize) || BOUNDARY_CONFIG.size.default;

  if (size > 80) {
    // 大图片: 35%-65% 范围，防止溢出
    return { min: 35, max: 65 };
  } else if (size > 60) {
    // 中图片: 30%-70% 范围
    return { min: 30, max: 70 };
  } else {
    // 小图片: 使用默认范围 25%-75%
    return BOUNDARY_CONFIG.position;
  }
};
```

### 5. 集成到现有组件

#### 5.1 修改 Preview 组件

```javascript
// src/component/Preview/Preview.jsx (修改部分)
import DraggableImage from "@/component/DraggableImage/DraggableImage";

function Preview() {
  // ... 现有代码保持不变

  return (
    <div className={styles.preview}>
      <Header download={downloadImagePlus} />

      <div className={styles.downloadWrapper}>
        <div
          className={styles.hidden}
          style={{ ...getRatioStyle(_Ratio) }}
          id={ID_DOWNLOAD_AREA}
        >
          {/* 使用新的可拖拽图片组件替换原有图片 */}
          <DraggableImage />

          <div
            className={styles.download}
            style={{
              ...getRatioStyle(_Ratio),
              ...getBackgroundStyle(
                _BackgroundType,
                _ImageBase64Url,
                _BackgroundColor
              ),
              ..._FilterStyle,
            }}
          />
        </div>
      </div>
    </div>
  );
}
```

### 6. 性能优化方案

#### 6.1 拖拽性能优化

```javascript
// 使用 requestAnimationFrame 优化拖拽性能
const useOptimizedDrag = () => {
  const frameRef = useRef();

  const handleMouseMove = useCallback(
    (event) => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }

      frameRef.current = requestAnimationFrame(() => {
        const newPosition = calculateNewPosition(event.clientX, event.clientY);
        if (newPosition) {
          updateImageStyle({
            ..._ImageStyle,
            top: `${newPosition.top}%`,
            left: `${newPosition.left}%`,
          });
        }
      });
    },
    [calculateNewPosition, updateImageStyle, _ImageStyle]
  );

  // 清理函数
  useEffect(() => {
    return () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
    };
  }, []);
};
```

#### 6.2 状态更新优化

```javascript
// 使用防抖减少状态更新频率
import { debounce } from "lodash";

const debouncedUpdateStyle = useMemo(
  () =>
    debounce((newStyle) => {
      updateImageStyle(newStyle);
    }, 16), // 约 60fps
  [updateImageStyle]
);
```

### 7. 边界处理和错误处理

#### 7.1 边界限制逻辑重新设计

**现有边界规则存在的问题：**

- 垂直位置（top）：min=25, max=75 - **固定边界，不考虑图片大小**
- 水平位置（left）：min=25, max=75 - **固定边界，不考虑图片大小**
- 图片大小（size）：min=0, max=100

**问题分析：**

1. **忽略图片大小影响**：当图片很小（size=20%）时，25%-75%的限制过于严格
2. **大图片溢出风险**：当图片很大（size=90%）时，75%的位置可能导致图片溢出容器
3. **用户体验不佳**：固定边界限制了用户的操作灵活性
4. **不符合视觉直觉**：用户期望基于图片实际大小来判断可移动范围

**图片定位方式分析：**

```javascript
// 图片样式设置 - 基于左上角定位
const imageStyle = {
  top: `${top}%`, // 图片左上角的垂直位置
  left: `${left}%`, // 图片左上角的水平位置
  width: `${size}%`, // 图片宽度
};
```

因此图片的实际占用范围是：

- 水平：left% 到 left% + size%
- 垂直：top% 到 top% + size%

#### 7.2 新的动态边界控制方案

```javascript
// 动态边界计算 - 基于图片大小
const calculateDynamicBounds = (imageSize) => {
  const size = parseFloat(imageSize) || 50;
  const SAFETY_MARGIN = 5; // 5% 的安全边距，防止贴边

  // 基础边界：确保图片不会溢出容器
  const basicMin = SAFETY_MARGIN;
  const basicMax = 100 - size - SAFETY_MARGIN;

  // 处理极端情况
  if (size >= 90) {
    // 超大图片：只能在很小的范围内移动
    return {
      min: Math.max(basicMin, 5),
      max: Math.min(basicMax, 10),
      center: 5 + (Math.min(basicMax, 10) - Math.max(basicMin, 5)) / 2,
    };
  } else if (size >= 70) {
    // 大图片：适度限制移动范围
    return {
      min: basicMin,
      max: Math.max(basicMax, basicMin + 10),
      center: basicMin + (Math.max(basicMax, basicMin + 10) - basicMin) / 2,
    };
  } else if (size >= 30) {
    // 中等图片：正常的移动范围
    return {
      min: basicMin,
      max: basicMax,
      center: basicMin + (basicMax - basicMin) / 2,
    };
  } else {
    // 小图片：更大的移动自由度
    return {
      min: 0,
      max: 100 - size,
      center: (100 - size) / 2,
    };
  }
};

// 智能边界控制函数
const applySmartBounds = useCallback((left, top, currentImageSize) => {
  const bounds = calculateDynamicBounds(currentImageSize);

  return {
    left: Math.max(bounds.min, Math.min(bounds.max, left)),
    top: Math.max(bounds.min, Math.min(bounds.max, top)),
  };
}, []);

// 获取当前图片大小并应用动态边界
const applyBounds = useCallback(
  (left, top) => {
    // 从 store 获取当前图片大小
    const currentSize = parseFloat(_ImageStyle.width) || 50;
    return applySmartBounds(left, top, currentSize);
  },
  [_ImageStyle.width]
);
```

#### 7.3 边界控制的数学原理

```javascript
/**
 * 边界计算的数学模型：
 *
 * 给定：
 * - 容器大小：100%
 * - 图片大小：size%
 * - 图片位置：(left%, top%) - 左上角坐标
 * - 安全边距：margin%
 *
 * 约束条件：
 * 1. 图片左边不能超出容器：left% >= margin%
 * 2. 图片右边不能超出容器：left% + size% <= 100% - margin%
 * 3. 图片上边不能超出容器：top% >= margin%
 * 4. 图片下边不能超出容器：top% + size% <= 100% - margin%
 *
 * 因此边界范围为：
 * - min = margin%
 * - max = 100% - size% - margin%
 */

const BOUNDARY_MATH = {
  // 计算理论边界
  calculateTheoreticalBounds: (imageSize, safetyMargin = 5) => {
    const size = parseFloat(imageSize) || 0;
    const margin = safetyMargin;

    return {
      min: margin,
      max: Math.max(margin, 100 - size - margin),
      // 确保 max >= min，防止无效边界
      isValid: 100 - size - margin >= margin,
    };
  },

  // 检查位置是否在边界内
  isWithinBounds: (position, imageSize, safetyMargin = 5) => {
    const bounds = BOUNDARY_MATH.calculateTheoreticalBounds(
      imageSize,
      safetyMargin
    );
    return position >= bounds.min && position <= bounds.max;
  },
};
```

#### 7.4 新旧边界方案对比

| 图片大小 | 旧方案（固定 25%-75%） | 新方案（动态边界） | 优势说明               |
| -------- | ---------------------- | ------------------ | ---------------------- |
| **10%**  | 25%-75% (50%范围)      | 0%-90% (90%范围)   | 小图片有更大移动自由度 |
| **30%**  | 25%-75% (50%范围)      | 5%-65% (60%范围)   | 略微增加移动空间       |
| **50%**  | 25%-75% (50%范围)      | 5%-45% (40%范围)   | 防止图片溢出           |
| **70%**  | 25%-75% (50%范围)      | 5%-25% (20%范围)   | 大幅减少溢出风险       |
| **90%**  | 25%-75% (50%范围)      | 5%-10% (5%范围)    | 严格控制，防止溢出     |

**关键改进点：**

1. **响应图片大小**：边界范围根据图片实际大小动态调整
2. **防止溢出**：数学上保证图片不会超出容器边界
3. **保持美观**：始终保持 5%的安全边距，避免贴边
4. **用户体验**：小图片有更大操作空间，大图片受到合理约束

#### 7.5 更新配置文件

```javascript
// src/constant/boundary.js - 更新版本
export const BOUNDARY_CONFIG = {
  // 安全边距配置
  safetyMargin: 5, // 5% 的最小边距

  // 图片大小分级
  sizeCategories: {
    small: { max: 30, marginBonus: 5 }, // 小图片：额外5%自由度
    medium: { max: 70, marginBonus: 0 }, // 中图片：标准边距
    large: { max: 90, marginBonus: -5 }, // 大图片：收紧5%
    extraLarge: { max: 100, marginBonus: -10 }, // 超大图片：严格控制
  },

  // 动态边界计算
  calculateBounds: (imageSize) => {
    const size = parseFloat(imageSize) || 50;
    const { safetyMargin, sizeCategories } = BOUNDARY_CONFIG;

    // 确定图片类别
    let category = "extraLarge";
    for (const [key, config] of Object.entries(sizeCategories)) {
      if (size <= config.max) {
        category = key;
        break;
      }
    }

    const effectiveMargin = Math.max(
      0,
      safetyMargin + sizeCategories[category].marginBonus
    );
    const min = effectiveMargin;
    const max = Math.max(min, 100 - size - effectiveMargin);

    return { min, max, isValid: max >= min };
  },
};
```

#### 7.6 建议的 ImageControl 组件更新

为了实现拖拽和滑动条的完全一致性，建议同时更新 ImageControl 组件：

```javascript
// 更新后的 ImageControl.jsx
import { BOUNDARY_CONFIG } from "@/constant/boundary";

function ImageControl() {
  const [top, setTop] = useState(50);
  const [left, setLeft] = useState(50);
  const [size, setSize] = useState(50);
  const { updateImageStyle, _ImageStyle } = useStore();

  // 实时计算边界范围
  const bounds = useMemo(() => {
    return BOUNDARY_CONFIG.calculateBounds(size);
  }, [size]);

  // 当图片大小变化时，确保位置在有效范围内
  useEffect(() => {
    if (!bounds.isValid) return;

    const adjustedLeft = Math.max(bounds.min, Math.min(bounds.max, left));
    const adjustedTop = Math.max(bounds.min, Math.min(bounds.max, top));

    if (adjustedLeft !== left) setLeft(adjustedLeft);
    if (adjustedTop !== top) setTop(adjustedTop);
  }, [bounds, left, top]);

  return (
    <div className={styles.wrapper}>
      <InlineControl label={"垂直位置"}>
        <Slider
          min={bounds.min}
          max={bounds.max}
          step={1}
          value={top}
          onChange={setTop}
        />
        <span className={styles.boundInfo}>
          范围: {bounds.min.toFixed(0)}% - {bounds.max.toFixed(0)}%
        </span>
      </InlineControl>

      <InlineControl label={"水平位置"}>
        <Slider
          min={bounds.min}
          max={bounds.max}
          step={1}
          value={left}
          onChange={setLeft}
        />
        <span className={styles.boundInfo}>
          范围: {bounds.min.toFixed(0)}% - {bounds.max.toFixed(0)}%
        </span>
      </InlineControl>

      <InlineControl label={"图片大小"}>
        <Slider min={0} max={100} step={1} value={size} onChange={setSize} />
      </InlineControl>

      {/* 其他控件保持不变 */}
    </div>
  );
}
```

**更新的关键优势：**

1. **动态边界同步**：滑动条的 min/max 值随图片大小实时更新
2. **防止无效状态**：当图片大小变化时，自动调整位置到有效范围
3. **用户反馈**：显示当前可用的位置范围，让用户了解约束
4. **完全一致性**：拖拽和滑动条使用相同的边界计算逻辑

#### 7.7 视觉边界提示

```javascript
// 基于动态边界的视觉提示
const getBoundaryWarning = (left, top, imageSize) => {
  const bounds = BOUNDARY_CONFIG.calculateBounds(imageSize);
  if (!bounds.isValid) return [];

  const threshold = Math.min(3, (bounds.max - bounds.min) * 0.1); // 动态阈值
  const warnings = [];

  if (left <= bounds.min + threshold) warnings.push("left-boundary");
  if (left >= bounds.max - threshold) warnings.push("right-boundary");
  if (top <= bounds.min + threshold) warnings.push("top-boundary");
  if (top >= bounds.max - threshold) warnings.push("bottom-boundary");

  return warnings;
};

// 在拖拽过程中显示边界警告和可视化提示
const handleMouseMove = useCallback(
  (event) => {
    const newPosition = calculateNewPosition(event.clientX, event.clientY);
    if (!newPosition) return;

    const currentSize = parseFloat(_ImageStyle.width) || 50;

    // 检查是否接近边界
    const warnings = getBoundaryWarning(
      newPosition.left,
      newPosition.top,
      currentSize
    );
    const bounds = BOUNDARY_CONFIG.calculateBounds(currentSize);

    // 计算距离边界的百分比（用于视觉反馈强度）
    const distanceToEdge = Math.min(
      newPosition.left - bounds.min,
      bounds.max - newPosition.left,
      newPosition.top - bounds.min,
      bounds.max - newPosition.top
    );
    const maxDistance = (bounds.max - bounds.min) / 2;
    const proximityRatio = Math.max(0, 1 - distanceToEdge / maxDistance);

    if (warnings.length > 0) {
      // 显示边界提示样式，强度基于接近程度
      setIsNearBoundary(true);
      setBoundaryWarnings(warnings);
      setBoundaryProximity(proximityRatio);
    } else {
      setIsNearBoundary(false);
      setBoundaryWarnings([]);
      setBoundaryProximity(0);
    }

    // 更新位置
    updateImageStyle({
      ..._ImageStyle,
      top: `${newPosition.top}%`,
      left: `${newPosition.left}%`,
    });
  },
  [calculateNewPosition, updateImageStyle, _ImageStyle]
);

// 可视化边界线组件
const BoundaryIndicator = ({ imageSize, isVisible }) => {
  const bounds = BOUNDARY_CONFIG.calculateBounds(imageSize);

  if (!bounds.isValid || !isVisible) return null;

  return (
    <div className={styles.boundaryIndicator}>
      {/* 顶部边界线 */}
      <div
        className={styles.boundaryLine}
        style={{
          top: `${bounds.min}%`,
          left: `${bounds.min}%`,
          right: `${100 - bounds.max}%`,
          height: "1px",
        }}
      />
      {/* 底部边界线 */}
      <div
        className={styles.boundaryLine}
        style={{
          top: `${bounds.max}%`,
          left: `${bounds.min}%`,
          right: `${100 - bounds.max}%`,
          height: "1px",
        }}
      />
      {/* 左侧边界线 */}
      <div
        className={styles.boundaryLine}
        style={{
          left: `${bounds.min}%`,
          top: `${bounds.min}%`,
          bottom: `${100 - bounds.max}%`,
          width: "1px",
        }}
      />
      {/* 右侧边界线 */}
      <div
        className={styles.boundaryLine}
        style={{
          left: `${bounds.max}%`,
          top: `${bounds.min}%`,
          bottom: `${100 - bounds.max}%`,
          width: "1px",
        }}
      />
    </div>
  );
};
```

#### 7.8 错误处理

```javascript
// 容错处理
const handleMouseDown = useCallback((event) => {
  try {
    // ... 拖拽逻辑
  } catch (error) {
    console.error("拖拽初始化失败:", error);
    // 降级到原有的滑动条控制
  }
}, []);
```

### 8. 用户体验增强

#### 8.1 视觉反馈

- **拖拽指示**: 鼠标悬停时显示 grab 光标
- **拖拽状态**: 拖拽时显示 grabbing 光标和轻微放大效果
- **边界提示**: 接近边界时显示警告颜色

#### 8.2 操作提示

```javascript
// 首次使用提示
const showDragHint = () => {
  if (isFirstTime) {
    // 显示操作提示："点击图片并拖拽来调整位置"
  }
};
```

### 9. 测试验证方案

#### 9.1 功能测试用例

1. **基础拖拽**: 点击图片能否正常开始拖拽
2. **位置同步**: 拖拽过程中右侧滑动条是否实时更新
3. **边界限制**: 拖拽超出边界时是否正确限制
4. **状态保持**: 拖拽完成后位置是否正确保存
5. **性能测试**: 快速拖拽时是否流畅无卡顿

#### 9.2 兼容性测试

- 不同浏览器的鼠标事件兼容性
- 移动设备的触摸事件适配
- 不同图片大小和比例的处理

## 📝 详细任务拆分方案

### 任务拆分原则

为了更好地管控质量和便于验收，将图片拖拽功能拆分为**8 个独立的子任务**，每个任务都有明确的：

- **功能边界**：清晰定义任务范围
- **验收标准**：具体的测试用例和成功标准
- **依赖关系**：明确任务间的先后顺序
- **工作量评估**：预计开发时间

### 🎯 子任务详细拆分

#### 任务 1：边界配置系统 (Foundation)

**优先级**: 高 | **预估工时**: 1 天 | **依赖**: 无

**功能范围:**

- 创建 `src/constant/boundary.js` 配置文件
- 实现动态边界计算算法
- 提供边界检查工具函数
- **同步更新 ImageControl 组件使用新边界系统**

**具体实现:**

```javascript
// 需要实现的核心函数
export const BOUNDARY_CONFIG = {
  calculateBounds: (imageSize) => ({ min, max, isValid }),
  safetyMargin: 5,
  sizeCategories: { small, medium, large, extraLarge },
};

export const clampPosition = (left, top, imageSize) => ({ left, top });
export const isWithinBounds = (position, imageSize) => boolean;
```

**验收标准:**

- [ ] 不同图片大小(10%, 30%, 50%, 70%, 90%)的边界计算正确
- [ ] 边界计算数学公式验证：`min = 5, max = 100 - size - 5`
- [ ] 极端情况处理：size >= 90% 时边界有效性检查
- [ ] **ImageControl 组件滑动条边界与新系统完全一致**
- [ ] **图片大小变化时，位置滑动条范围自动更新**
- [ ] **现有的滑动条操作不受影响（向后兼容）**
- [ ] 单元测试覆盖率 ≥ 90%

**测试用例:**

```javascript
// 边界计算测试
expect(BOUNDARY_CONFIG.calculateBounds(50)).toEqual({
  min: 5,
  max: 45,
  isValid: true,
});
expect(clampPosition(80, 80, 50)).toEqual({ left: 45, top: 45 });

// ImageControl集成测试
const { getByTestId } = render(<ImageControl />);
const sizeSlider = getByTestId("size-slider");
const positionSlider = getByTestId("position-slider");

// 改变图片大小，验证位置滑动条范围更新
fireEvent.change(sizeSlider, { target: { value: 80 } });
expect(positionSlider.min).toBe(5); // 新的最小值
expect(positionSlider.max).toBe(15); // 新的最大值 (100-80-5)
```

---

#### 任务 2：基础拖拽 Hook (Core Logic)

**优先级**: 高 | **预估工时**: 1 天 | **依赖**: 任务 1

**功能范围:**

- 实现 `useDrag` Hook 的核心拖拽逻辑
- 处理鼠标事件(mousedown, mousemove, mouseup)
- 坐标转换和边界限制

**具体实现:**

```javascript
// Hook 接口设计
export const useDrag = (imageRef) => {
  return {
    isDragging: boolean,
    handleMouseDown: (event) => void,
    // 内部实现坐标转换和边界检查
  };
};
```

**验收标准:**

- [ ] 鼠标按下时正确启动拖拽状态
- [ ] 鼠标移动时实时计算新位置
- [ ] 鼠标释放时正确结束拖拽状态
- [ ] 坐标转换准确：鼠标位置 → 百分比位置
- [ ] 边界限制生效：位置被正确约束在有效范围内
- [ ] 内存泄漏测试：事件监听器正确移除

**测试用例:**

```javascript
// 模拟拖拽测试
const mockImageRef = { current: mockElement };
const { result } = renderHook(() => useDrag(mockImageRef));
// 测试 mousedown -> mousemove -> mouseup 流程
```

---

#### 任务 3：可拖拽图片组件 (UI Component)

**优先级**: 高 | **预估工时**: 0.5 天 | **依赖**: 任务 2

**功能范围:**

- 创建 `DraggableImage` 组件
- 集成 `useDrag` Hook
- 处理图片的拖拽样式和状态

**具体实现:**

```javascript
// 组件接口
function DraggableImage() {
  // 使用 useDrag Hook
  // 处理图片样式和比例
  // 返回可拖拽的 img 元素
}
```

**验收标准:**

- [ ] 图片正确显示并保持比例
- [ ] 鼠标悬停时显示 grab 光标
- [ ] 拖拽时显示 grabbing 光标
- [ ] 拖拽状态下图片有视觉反馈(轻微放大/高亮)
- [ ] 无图片时组件正确隐藏
- [ ] 组件性能：无不必要的重渲染

**测试用例:**

```javascript
// 组件渲染测试
render(<DraggableImage />);
// 测试不同状态下的样式变化
// 测试拖拽交互行为
```

---

#### 任务 4：Preview 组件集成 (Integration)

**优先级**: 高 | **预估工时**: 0.5 天 | **依赖**: 任务 3

**功能范围:**

- 将 `DraggableImage` 集成到现有 `Preview` 组件
- 替换原有的静态图片元素
- 确保与现有功能兼容

**具体实现:**

```javascript
// Preview.jsx 修改
import DraggableImage from "@/component/DraggableImage/DraggableImage";

// 替换原有的 <img> 标签
<DraggableImage />;
```

**验收标准:**

- [ ] 拖拽图片正确替换原有图片显示
- [ ] 图片位置、大小、样式保持一致
- [ ] 背景层正确显示在图片下方
- [ ] 导出功能正常工作
- [ ] 现有的所有功能不受影响

**测试用例:**

```javascript
// 集成测试
// 验证拖拽功能与现有功能的兼容性
// 测试导出图片包含拖拽后的位置
```

---

#### 任务 5：状态同步机制 (State Management)

**优先级**: 高 | **预估工时**: 0.5 天 | **依赖**: 任务 4

**功能范围:**

- 实现拖拽过程中与 Zustand store 的状态同步
- 确保右侧控制面板滑动条实时更新
- 处理状态更新的性能优化

**具体实现:**

```javascript
// 在拖拽过程中更新 store
updateImageStyle({
  ..._ImageStyle,
  top: `${newPosition.top}%`,
  left: `${newPosition.left}%`,
});
```

**验收标准:**

- [ ] 拖拽时右侧"垂直位置"滑动条实时跟随
- [ ] 拖拽时右侧"水平位置"滑动条实时跟随
- [ ] 拖拽结束后状态正确保存
- [ ] 滑动条操作与拖拽操作状态完全一致
- [ ] 性能测试：拖拽过程流畅，无卡顿

**测试用例:**

```javascript
// 状态同步测试
// 模拟拖拽，验证store状态变化
// 验证UI控件的响应性
```

---

#### 任务 6：~~ImageControl 组件更新~~ (已合并到任务 1)

**状态**: ⚠️ **已合并到任务 1** - 避免边界系统不一致问题

**原因说明:**

- 如果单独实现，会造成边界系统不一致
- 任务 1 完成后，拖拽边界和滑动条边界可能不同步
- 用户体验会出现混乱：拖拽和滑动条操作结果不一致

**合并后的好处:**

- 确保边界系统从一开始就是统一的
- 避免中间状态的不一致问题
- 降低集成风险

---

#### 任务 7：视觉反馈系统 (Visual Feedback)

**优先级**: 中 | **预估工时**: 0.5 天 | **依赖**: 任务 5

**功能范围:**

- 实现拖拽过程中的视觉反馈
- 边界接近警告
- 可选的边界线显示

**具体实现:**

```javascript
// 视觉反馈组件
<BoundaryIndicator imageSize={size} isVisible={isDragging} />
// 接近边界时的样式变化
```

**验收标准:**

- [ ] 拖拽时图片有适当的视觉反馈
- [ ] 接近边界时有警告提示
- [ ] 拖拽区域边界线清晰可见（可选功能）
- [ ] 视觉效果不影响性能
- [ ] 样式与整体设计风格一致

**测试用例:**

```javascript
// 视觉反馈测试
// 验证不同拖拽状态下的样式变化
```

---

#### 任务 8：完整测试与优化 (Testing & Polish)

**优先级**: 中 | **预估工时**: 1 天 | **依赖**: 任务 1-7

**功能范围:**

- 综合功能测试
- 性能优化
- 错误处理
- 兼容性验证

**具体实现:**

```javascript
// 性能优化：requestAnimationFrame
// 错误处理：边界情况
// 兼容性：不同浏览器测试
```

**验收标准:**

- [ ] 所有子任务功能集成正常
- [ ] 性能测试：拖拽流畅度 ≥ 60fps
- [ ] 错误处理：异常情况不崩溃
- [ ] 兼容性：Chrome、Firefox、Safari 正常工作
- [ ] 回归测试：现有功能无损坏
- [ ] 用户体验：操作直观流畅

**测试用例:**

```javascript
// 端到端测试
// 性能基准测试
// 错误注入测试
```

### 📋 任务依赖关系图

```
任务1(边界配置+控件更新) → 任务2(拖拽Hook) → 任务3(组件) → 任务4(集成)
                                                              ↓
                                                         任务5(状态同步)
                                                              ↓
                                                         任务7(视觉反馈)
                                                              ↓
                                                         任务8(测试优化)
```

**变更说明:**

- 任务 6 已合并到任务 1，简化为线性依赖关系
- 降低了并行开发的复杂度，但确保了系统一致性

### 🚀 开发建议

1. **线性开发**: 由于合并了边界系统，建议按顺序开发以确保一致性
2. **增量验收**: 每个任务完成后立即进行验收
3. **质量控制**: 每个任务都包含单元测试和集成测试
4. **风险控制**: 任务 1 和任务 4 是关键节点，需要重点关注

### ⚠️ 重要变更：边界系统一致性保证

**问题识别:**

- 原方案可能导致拖拽边界和滑动条边界不一致
- 会影响现有的控制栏功能和用户体验

**解决方案:**

- 将 ImageControl 组件更新合并到任务 1
- 确保边界系统从实现开始就是统一的
- 任务 1 完成后，拖拽和滑动条使用相同的边界逻辑

**用户体验保证:**

- 滑动条操作和拖拽操作结果完全一致
- 图片大小变化时，所有控制方式的边界同步更新
- 不会出现"能拖拽到但滑动条设置不了"的困惑情况

### 代码质量保证

- 保持现有的 ESLint 规范
- 添加详细的代码注释
- 使用 TypeScript 类型定义（如果适用）
- 遵循现有的组件命名和结构约定

### 向后兼容性

- 保留原有的滑动条控制功能
- 新功能作为增强，不影响现有工作流
- 提供开关选项，允许用户选择操作方式

---

_此方案提供了完整的技术实现路径，可以根据实际开发进度进行调整和优化_
